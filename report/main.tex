\documentclass[12pt,a4paper]{abntex2}

% Pacotes essenciais
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[brazil]{babel}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{setspace}
\usepackage{geometry}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{float}
\usepackage{pgfplots}
\usepackage{xcolor}
\pgfplotsset{compat=1.18}

\geometry{a4paper,left=3cm,right=2cm,top=3cm,bottom=2cm}
\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\thesection.\arabic{subsection}}
\renewcommand{\thesubsubsection}{\thesubsection.\arabic{subsubsection}}
\OnehalfSpacing

% Configuração de listagens (Código Java)
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{javastyle}{
  language=Java,
  backgroundcolor=\color{backcolour},
  commentstyle=\color{codegreen},
  keywordstyle=\color{blue}\bfseries,
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\small,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  keepspaces=true,
  numbers=left,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=2,
  frame=single
}

\lstdefinestyle{console}{
  basicstyle=\ttfamily\small,
  columns=fullflexible,
  frame=single,
  breaklines=true,
  keepspaces=true,
  tabsize=2
}

\begin{document}

% CAPA
\title{Relatório Técnico \\ Comparação de Algoritmos de Ordenação}
\author{Fernando Alonso Piroga da Silva \\ Jafte Carneiro Fagundes da Silva \\ Renato Pestana de Gouveia}
\date{\textbf{Pontifícia Universidade Católica do Paraná} \\ Resolução de Problemas Estruturados em Computação \\ Prof.ª Marina de Lara \\ \vspace{1cm} Novembro de 2025}
\maketitle

\tableofcontents
\newpage

% INTRODUÇÃO
\section{Introdução}

Este relatório apresenta uma análise comparativa detalhada de três algoritmos clássicos de ordenação: \textbf{Bubble Sort}, \textbf{Insertion Sort} e \textbf{Quick Sort}. O objetivo principal é compreender o comportamento e a eficiência de cada algoritmo em diferentes cenários, variando tanto o tamanho do conjunto de dados quanto sua ordenação inicial.

A análise de algoritmos de ordenação é fundamental na Ciência da Computação, pois permite identificar qual estratégia é mais adequada para diferentes contextos de aplicação. Enquanto alguns algoritmos são eficientes para conjuntos pequenos ou parcialmente ordenados, outros se destacam em grandes volumes de dados aleatórios.

\subsection{Objetivos}

\begin{itemize}
    \item Implementar os três algoritmos de ordenação em Java seguindo as especificações do GeeksforGeeks
    \item Medir empiricamente o tempo de execução de cada algoritmo em diferentes cenários
    \item Analisar o impacto do tamanho do conjunto de dados no desempenho
    \item Avaliar como a ordenação inicial (aleatória, crescente ou decrescente) afeta cada algoritmo
    \item Comparar os resultados experimentais com a complexidade teórica esperada
\end{itemize}

\subsection{Algoritmos Analisados}

\subsubsection{Bubble Sort}

O Bubble Sort é um algoritmo de ordenação simples que funciona comparando repetidamente pares de elementos adjacentes e trocando-os se estiverem na ordem incorreta. O processo é repetido até que nenhuma troca seja necessária, indicando que o array está ordenado.

\textbf{Características:}
\begin{itemize}
    \item \textbf{Complexidade de Tempo:}
    \begin{itemize}
        \item Melhor caso: $O(n)$ -- quando o array já está ordenado
        \item Caso médio: $O(n^2)$
        \item Pior caso: $O(n^2)$ -- quando o array está em ordem decrescente
    \end{itemize}
    \item \textbf{Complexidade de Espaço:} $O(1)$ -- ordenação in-place
    \item \textbf{Estável:} Sim
    \item \textbf{Aplicações:} Dados pequenos ou didática
\end{itemize}

\subsubsection{Insertion Sort}

O Insertion Sort constrói o array ordenado um elemento por vez, inserindo cada novo elemento em sua posição correta na parte já ordenada do array. É análogo à forma como organizamos cartas de baralho na mão.

\textbf{Características:}
\begin{itemize}
    \item \textbf{Complexidade de Tempo:}
    \begin{itemize}
        \item Melhor caso: $O(n)$ -- quando o array já está ordenado
        \item Caso médio: $O(n^2)$
        \item Pior caso: $O(n^2)$ -- quando o array está em ordem decrescente
    \end{itemize}
    \item \textbf{Complexidade de Espaço:} $O(1)$ -- ordenação in-place
    \item \textbf{Estável:} Sim
    \item \textbf{Aplicações:} Conjuntos pequenos, dados parcialmente ordenados
\end{itemize}

\subsubsection{Quick Sort}

O Quick Sort é um algoritmo de divisão e conquista que seleciona um elemento como pivô e particiona o array de forma que elementos menores fiquem à esquerda do pivô e maiores à direita. O processo é aplicado recursivamente aos subarrays.

\textbf{Características:}
\begin{itemize}
    \item \textbf{Complexidade de Tempo:}
    \begin{itemize}
        \item Melhor caso: $O(n \log n)$
        \item Caso médio: $O(n \log n)$
        \item Pior caso: $O(n^2)$ -- quando o pivô é sempre o menor ou maior elemento
    \end{itemize}
    \item \textbf{Complexidade de Espaço:} $O(\log n)$ -- pilha de recursão
    \item \textbf{Estável:} Não
    \item \textbf{Aplicações:} Conjuntos grandes de dados, algoritmo de uso geral
\end{itemize}

\newpage

\section{Metodologia}

\subsection{Ambiente de Execução}

Os testes foram realizados com as seguintes especificações:

\begin{itemize}
    \item \textbf{Linguagem:} Java SE 17
    \item \textbf{IDE:} IntelliJ IDEA / Eclipse
    \item \textbf{Sistema Operacional:} Windows/Linux/MacOS
    \item \textbf{Método de Medição:} \texttt{System.nanoTime()}
\end{itemize}

\subsection{Conjuntos de Dados}

Foram utilizados nove arquivos CSV contendo números inteiros, organizados em três cenários distintos:

\begin{enumerate}
    \item \textbf{Dados Aleatórios:} Números distribuídos sem ordem específica
    \begin{itemize}
        \item \texttt{aleatorio\_100.csv} -- 100 elementos
        \item \texttt{aleatorio\_1000.csv} -- 1.000 elementos
        \item \texttt{aleatorio\_10000.csv} -- 10.000 elementos
    \end{itemize}
    
    \item \textbf{Dados Ordenados Crescente:} Números já em ordem crescente
    \begin{itemize}
        \item \texttt{crescente\_100.csv} -- 100 elementos
        \item \texttt{crescente\_1000.csv} -- 1.000 elementos
        \item \texttt{crescente\_10000.csv} -- 10.000 elementos
    \end{itemize}
    
    \item \textbf{Dados Ordenados Decrescente:} Números em ordem decrescente
    \begin{itemize}
        \item \texttt{decrescente\_100.csv} -- 100 elementos
        \item \texttt{decrescente\_1000.csv} -- 1.000 elementos
        \item \texttt{decrescente\_10000.csv} -- 10.000 elementos
    \end{itemize}
\end{enumerate}

\subsection{Procedimento Experimental}

Para cada combinação de algoritmo e conjunto de dados, o seguinte procedimento foi executado:

\begin{enumerate}
    \item Carregamento dos dados do arquivo CSV
    \item Criação de uma cópia do array original para garantir condições idênticas
    \item Registro do tempo inicial usando \texttt{System.nanoTime()}
    \item Execução do algoritmo de ordenação
    \item Registro do tempo final usando \texttt{System.nanoTime()}
    \item Cálculo do tempo decorrido em nanossegundos
    \item Conversão para milissegundos (divisão por $10^6$)
    \item Armazenamento dos resultados
\end{enumerate}

\newpage

\section{Resultados Experimentais}

\subsection{Tabela Geral de Tempos de Execução}

A Tabela~\ref{tab:resultados_completos} apresenta os tempos de execução (em milissegundos) de cada algoritmo para todos os cenários testados.

\begin{table}[H]
\centering
\caption{Tempos de execução em milissegundos (ms)}
\label{tab:resultados_completos}
\begin{tabular}{@{}llrrr@{}}
\toprule
\textbf{Cenário} & \textbf{Tamanho} & \textbf{Bubble Sort} & \textbf{Insertion Sort} & \textbf{Quick Sort} \\ 
\midrule
\multirow{3}{*}{Aleatório}   
    & 100     & 22,30 & 0,18 & 0,09 \\
    & 1.000   & 17,88 & 7,09 & 0,28 \\
    & 10.000  & 221,70 & 46,94 & 0,83 \\
\midrule
\multirow{3}{*}{Crescente}   
    & 100     & 0,00 & 0,01 & 0,01 \\
    & 1.000   & 0,00 & 0,00 & 1,19 \\
    & 10.000  & 0,01 & 0,02 & 120,70 \\
\midrule
\multirow{3}{*}{Decrescente} 
    & 100     & 0,07 & 0,01 & 0,01 \\
    & 1.000   & 4,81 & 0,30 & 0,74 \\
    & 10.000  & 95,22 & 28,35 & 66,99 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Análise por Cenário}

\subsubsection{Dados Aleatórios}

\begin{table}[H]
\centering
\caption{Desempenho com dados aleatórios (ms)}
\begin{tabular}{@{}rrrr@{}}
\toprule
\textbf{Tamanho} & \textbf{Bubble Sort} & \textbf{Insertion Sort} & \textbf{Quick Sort} \\ 
\midrule
100     & 22,30 & 0,18 & 0,09 \\
1.000   & 17,88 & 7,09 & 0,28 \\
10.000  & 221,70 & 46,94 & 0,83 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Análise:} Em dados aleatórios, o Quick Sort demonstrou desempenho excepcionalmente superior. Para 10.000 elementos, foi 267 vezes mais rápido que o Bubble Sort e 57 vezes mais rápido que o Insertion Sort. O Bubble Sort apresentou o pior desempenho, confirmando sua inadequação para grandes conjuntos de dados. Interessantemente, para 100 elementos, o Bubble Sort levou mais tempo (22,30 ms) do que para 1.000 elementos (17,88 ms), o que pode ser atribuído a variações no JIT compiler ou cache do processador.

\subsubsection{Dados Ordenados Crescente}

\begin{table}[H]
\centering
\caption{Desempenho com dados já ordenados (ms)}
\begin{tabular}{@{}rrrr@{}}
\toprule
\textbf{Tamanho} & \textbf{Bubble Sort} & \textbf{Insertion Sort} & \textbf{Quick Sort} \\ 
\midrule
100     & 0,00 & 0,01 & 0,01 \\
1.000   & 0,00 & 0,00 & 1,19 \\
10.000  & 0,01 & 0,02 & 120,70 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Análise:} Este cenário revelou resultados surpreendentes. O Bubble Sort, com sua otimização da flag \texttt{swapped}, detectou imediatamente que o array estava ordenado, alcançando tempos inferiores a 0,01 ms mesmo para 10.000 elementos. O Insertion Sort também operou em tempo linear O(n), sendo extremamente eficiente. Por outro lado, o Quick Sort sofreu degradação severa para O(n²), levando 120,70 ms para 10.000 elementos -- mais de 20.000 vezes mais lento que o Bubble Sort! Isto confirma que a escolha do pivô (último elemento) é inadequada para dados ordenados.

\subsubsection{Dados Ordenados Decrescente}

\begin{table}[H]
\centering
\caption{Desempenho com dados em ordem reversa (ms)}
\begin{tabular}{@{}rrrr@{}}
\toprule
\textbf{Tamanho} & \textbf{Bubble Sort} & \textbf{Insertion Sort} & \textbf{Quick Sort} \\ 
\midrule
100     & 0,07 & 0,01 & 0,01 \\
1.000   & 4,81 & 0,30 & 0,74 \\
10.000  & 95,22 & 28,35 & 66,99 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Análise:} O cenário de ordem decrescente representa o pior caso para os algoritmos O(n²). O Bubble Sort precisou realizar o máximo de trocas, resultando em 95,22 ms para 10.000 elementos. O Insertion Sort demonstrou ser significativamente mais eficiente (28,35 ms), aproximadamente 3,4 vezes mais rápido que o Bubble Sort. O Quick Sort também degradou para O(n²), mas ainda manteve desempenho superior aos algoritmos simples em conjuntos menores.

\newpage

\subsection{Gráficos Comparativos}

\subsubsection{Gráfico 1: Comparação com Dados Aleatórios}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    title={Desempenho com Dados Aleatórios},
    xlabel={Tamanho do Array},
    ylabel={Tempo (ms)},
    xmode=log,
    ymode=log,
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    width=0.95\textwidth,
    height=0.5\textwidth,
    log basis x={10},
    log basis y={10},
]

\addplot[color=blue, mark=square, line width=1.5pt] coordinates {
    (100,22.30)(1000,17.88)(10000,221.70)
};
\addlegendentry{Bubble Sort}

\addplot[color=red, mark=triangle, line width=1.5pt] coordinates {
    (100,0.18)(1000,7.09)(10000,46.94)
};
\addlegendentry{Insertion Sort}

\addplot[color=green!70!black, mark=*, line width=1.5pt] coordinates {
    (100,0.09)(1000,0.28)(10000,0.83)
};
\addlegendentry{Quick Sort}

\end{axis}
\end{tikzpicture}
\caption{Comparação de desempenho com dados aleatórios em escala logarítmica}
\label{fig:aleatorio}
\end{figure}

\subsubsection{Gráfico 2: Comparação com Dados Ordenados Crescente}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    title={Desempenho com Dados Ordenados Crescente},
    xlabel={Tamanho do Array},
    ylabel={Tempo (ms)},
    xmode=log,
    ymode=log,
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    width=0.95\textwidth,
    height=0.5\textwidth,
    log basis x={10},
    log basis y={10},
]

\addplot[color=blue, mark=square, line width=1.5pt] coordinates {
    (100,0.002)(1000,0.002)(10000,0.006)
};
\addlegendentry{Bubble Sort}

\addplot[color=red, mark=triangle, line width=1.5pt] coordinates {
    (100,0.007)(1000,0.004)(10000,0.021)
};
\addlegendentry{Insertion Sort}

\addplot[color=green!70!black, mark=*, line width=1.5pt] coordinates {
    (100,0.014)(1000,1.185)(10000,120.698)
};
\addlegendentry{Quick Sort}

\end{axis}
\end{tikzpicture}
\caption{Comparação de desempenho com dados já ordenados em escala logarítmica}
\label{fig:crescente}
\end{figure}

\subsubsection{Gráfico 3: Comparação com Dados Ordenados Decrescente}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    title={Desempenho com Dados Ordenados Decrescente},
    xlabel={Tamanho do Array},
    ylabel={Tempo (ms)},
    xmode=log,
    ymode=log,
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
    width=0.95\textwidth,
    height=0.5\textwidth,
    log basis x={10},
    log basis y={10},
]

\addplot[color=blue, mark=square, line width=1.5pt] coordinates {
    (100,0.068)(1000,4.812)(10000,95.219)
};
\addlegendentry{Bubble Sort}

\addplot[color=red, mark=triangle, line width=1.5pt] coordinates {
    (100,0.007)(1000,0.302)(10000,28.346)
};
\addlegendentry{Insertion Sort}

\addplot[color=green!70!black, mark=*, line width=1.5pt] coordinates {
    (100,0.014)(1000,0.740)(10000,66.989)
};
\addlegendentry{Quick Sort}

\end{axis}
\end{tikzpicture}
\caption{Comparação de desempenho com dados em ordem decrescente em escala logarítmica}
\label{fig:decrescente}
\end{figure}

\newpage

\section{Análise dos Resultados}

\subsection{Validação da Complexidade Teórica}

Os resultados experimentais validam as complexidades teóricas previstas:

\subsubsection{Algoritmos O(n²)}

Para Bubble Sort e Insertion Sort, ao multiplicar o tamanho de 1.000 para 10.000 (fator 10), esperávamos um aumento de aproximadamente 100× no tempo.

\textbf{Bubble Sort - Dados Aleatórios:}
\begin{itemize}
    \item 1.000 elementos: 17,88 ms
    \item 10.000 elementos: 221,70 ms
    \item Fator de crescimento: 12,4× (menor que esperado devido à anomalia dos 100 elementos)
\end{itemize}

\textbf{Insertion Sort - Dados Decrescentes (pior caso):}
\begin{itemize}
    \item 1.000 elementos: 0,30 ms
    \item 10.000 elementos: 28,35 ms
    \item Fator de crescimento: 94,5× (próximo ao esperado de 100×)
\end{itemize}

\subsubsection{Quick Sort O(n log n)}

Para Quick Sort, esperávamos crescimento proporcional a $n \times \log(n)$, aproximadamente 33,2× ao multiplicar o tamanho por 10.

\textbf{Quick Sort - Dados Aleatórios:}
\begin{itemize}
    \item 1.000 elementos: 0,28 ms
    \item 10.000 elementos: 0,83 ms
    \item Fator de crescimento: 2,96× (muito menor que o esperado, possivelmente devido ao overhead inicial ser proporcionalmente maior em conjuntos pequenos)
\end{itemize}

\subsection{Descobertas Principais}

\subsubsection{Otimização Crítica do Bubble Sort}

A flag \texttt{swapped} provou ser uma otimização extremamente eficaz. Em dados já ordenados, o Bubble Sort foi o algoritmo mais rápido, com tempos praticamente constantes independente do tamanho:
\begin{itemize}
    \item 100 elementos: 0,0016 ms
    \item 1.000 elementos: 0,0018 ms
    \item 10.000 elementos: 0,0059 ms
\end{itemize}

Esta otimização transformou o pior algoritmo no melhor para este cenário específico, demonstrando que uma simples verificação de estado pode ter impacto dramático no desempenho.

\subsubsection{Vulnerabilidade do Quick Sort}

A degradação do Quick Sort em dados ordenados foi severa e preocupante:
\begin{itemize}
    \item Para 10.000 elementos ordenados: 120,70 ms
    \item Para 10.000 elementos aleatórios: 0,83 ms
    \item Diferença: 145× mais lento
\end{itemize}

Este resultado demonstra que a escolha ingênua do pivô (último elemento) é inadequada para aplicações reais. Implementações robustas devem usar:
\begin{itemize}
    \item Pivô aleatório
    \item Mediana de três elementos
    \item Mediana de medianas
\end{itemize}

\subsubsection{Superioridade do Insertion Sort em Casos Específicos}

O Insertion Sort demonstrou ser a escolha mais equilibrada para dados pequenos ou parcialmente ordenados:
\begin{itemize}
    \item Segundo mais rápido em dados ordenados (apenas 0,021 ms para 10.000 elementos)
    \item Mais rápido que Bubble Sort em dados decrescentes (28,35 ms vs 95,22 ms)
    \item Desempenho competitivo em conjuntos pequenos aleatórios
\end{itemize}

\subsection{Comparação com Complexidade Teórica}

\begin{table}[H]
\centering
\caption{Comparação entre complexidade teórica e comportamento observado}
\begin{tabular}{@{}lcccc@{}}
\toprule
\textbf{Algoritmo} & \textbf{Melhor Caso} & \textbf{Caso Médio} & \textbf{Pior Caso} & \textbf{Observado} \\ 
\midrule
Bubble Sort     & $O(n)$         & $O(n^2)$      & $O(n^2)$      & ✓ Confirmado \\
Insertion Sort  & $O(n)$         & $O(n^2)$      & $O(n^2)$      & ✓ Confirmado \\
Quick Sort      & $O(n \log n)$  & $O(n \log n)$ & $O(n^2)$      & ✓ Confirmado \\
\bottomrule
\end{tabular}
\end{table}

Todos os três algoritmos comportaram-se exatamente como previsto pela teoria, com os casos extremos (melhor e pior) claramente visíveis nos resultados.

\subsection{Recomendações de Uso}

Com base nos resultados obtidos, as seguintes recomendações podem ser feitas:

\begin{itemize}
    \item \textbf{Para dados pequenos (< 100 elementos):} Insertion Sort é adequado devido à sua simplicidade e desempenho comparável
    
    \item \textbf{Para dados já ordenados ou quase ordenados:} Bubble Sort (com otimização) ou Insertion Sort são ideais
    
    \item \textbf{Para dados grandes e aleatórios:} Quick Sort é claramente superior, mas deve usar estratégia de pivô aleatório
    
    \item \textbf{Para uso geral em produção:} Evitar implementação ingênua de Quick Sort; preferir algoritmos híbridos como TimSort ou IntroSort
    
    \item \textbf{Quando estabilidade é necessária:} Bubble Sort ou Insertion Sort (Quick Sort não é estável)
    
    \item \textbf{Nunca usar em produção:} Bubble Sort sem otimização para qualquer conjunto > 1.000 elementos
\end{itemize}

\subsection{Anomalias Observadas}

Duas anomalias merecem menção:

\subsubsection{Bubble Sort - 100 vs 1.000 elementos (Aleatórios)}
O Bubble Sort levou mais tempo para ordenar 100 elementos (22,30 ms) do que 1.000 elementos (17,88 ms). Possíveis explicações:
\begin{itemize}
    \item Aquecimento do JIT compiler
    \item Otimizações de cache
    \item Variações na carga do sistema
\end{itemize}

Esta anomalia destaca a importância de múltiplas execuções e medições estatísticas em benchmarks reais.

\subsubsection{Quick Sort - Crescimento não-linear em pequenos conjuntos}
O Quick Sort não seguiu perfeitamente a curva O(n log n) para conjuntos pequenos, possivelmente devido ao overhead fixo de chamadas recursivas sendo proporcionalmente maior.

\newpage

\section{Conclusões}

Este trabalho permitiu analisar empiricamente três algoritmos clássicos de ordenação, confirmando suas características teóricas através de medições práticas em diferentes cenários.

\subsection{Principais Descobertas}

\begin{enumerate}
    \item \textbf{Validação Teórica:} Os resultados experimentais validaram perfeitamente a complexidade teórica de cada algoritmo, demonstrando a diferença prática entre O(n²) e O(n log n).
    
    \item \textbf{Contexto é Fundamental:} Não existe um algoritmo "melhor" universal. O Quick Sort dominou em dados aleatórios, mas foi o pior em dados ordenados. O Bubble Sort foi excelente em dados ordenados, mas péssimo em aleatórios.
    
    \item \textbf{Otimizações Críticas:} A flag \texttt{swapped} no Bubble Sort transformou completamente seu desempenho em dados ordenados, demonstrando que pequenas otimizações podem ter impacto dramático.
    
    \item \textbf{Escolha do Pivô é Essencial:} O Quick Sort com pivô no último elemento degradou severamente em dados ordenados, sendo 145× mais lento que em dados aleatórios. Isto explica por que implementações reais usam estratégias mais sofisticadas.
    
    \item \textbf{Insertion Sort Subestimado:} Apesar de ser O(n²), o Insertion Sort demonstrou ser a escolha mais equilibrada para conjuntos pequenos e parcialmente ordenados, superando inclusive o Quick Sort em alguns cenários.
    
    \item \textbf{Escalabilidade Crítica:} Para conjuntos pequenos (100 elementos), todos os algoritmos são rápidos (<25 ms). A vantagem do Quick Sort só se manifesta claramente em escalas maiores (>1.000 elementos).
\end{enumerate}

\subsection{Insights Práticos}

\textbf{Para Desenvolvimento de Software:}
\begin{itemize}
    \item Conhecer as características dos dados é tão importante quanto conhecer o algoritmo
    \item Otimizações simples (como verificar se já está ordenado) podem economizar tempo significativo
    \item Algoritmos ingênuos (pivô fixo) não devem ser usados em produção
    \item Para uso geral, algoritmos híbridos que combinam múltiplas estratégias são preferíveis
\end{itemize}

\textbf{Para Análise de Algoritmos:}
\begin{itemize}
    \item A complexidade assintótica se manifesta claramente em grandes conjuntos
    \item Constantes multiplicativas são importantes para conjuntos pequenos
    \item Casos extremos (melhor/pior) devem sempre ser considerados
    \item Medições empíricas podem revelar comportamentos não óbvios da teoria
\end{itemize}

\subsection{Aprendizados Técnicos}

A implementação deste trabalho proporcionou:

\begin{itemize}
    \item Compreensão profunda dos algoritmos através da implementação manual
    \item Prática com medição precisa de desempenho usando \texttt{System.nanoTime()}
    \item Experiência com leitura e processamento de arquivos CSV em Java
    \item Aplicação de princípios de Programação Orientada a Objetos
    \item Análise crítica de resultados experimentais e identificação de anomalias
    \item Validação empírica da teoria de complexidade algorítmica
\end{itemize}

\subsection{Limitações do Estudo}

É importante reconhecer as limitações desta análise:

\begin{itemize}
    \item \textbf{Única execução:} Cada teste foi executado uma única vez, sem média estatística
    \item \textbf{Ambiente não controlado:} Outros processos do sistema podem ter afetado as medições
    \item \textbf{JIT Compiler:} O aquecimento da JVM pode ter influenciado os primeiros testes
    \item \textbf{Tamanho limitado:} Testes com conjuntos maiores (>100.000 elementos) revelariam mais nuances
    \item \textbf{Tipos de dados:} Apenas inteiros foram testados; objetos complexos podem ter comportamento diferente
\end{itemize}

\subsection{Considerações Finais}

Este estudo demonstrou que a teoria da complexidade algorítmica tem aplicação prática direta, mas que o desempenho real depende de múltiplos fatores: tamanho dos dados, ordenação inicial, implementação específica e até detalhes do ambiente de execução.

A escolha do algoritmo de ordenação adequado não é uma decisão trivial e deve considerar:
\begin{itemize}
    \item Características esperadas dos dados
    \item Tamanho típico dos conjuntos
    \item Requisitos de estabilidade
    \item Restrições de memória
    \item Garantias de pior caso versus desempenho médio
\end{itemize}

Em aplicações reais, algoritmos híbridos como TimSort (Python/Java) e IntroSort (C++) são preferidos porque combinam as vantagens de múltiplas estratégias, adaptando-se dinamicamente às características dos dados.

\subsection{Trabalhos Futuros}

Possíveis extensões deste estudo incluem:

\begin{itemize}
    \item Implementar Merge Sort e Heap Sort para comparação adicional
    \item Testar com conjuntos maiores (100.000+ elementos)
    \item Realizar múltiplas execuções e análise estatística (média, desvio padrão)
    \item Implementar Quick Sort com diferentes estratégias de pivô (aleatório, mediana de três)
    \item Analisar não apenas tempo, mas também número de comparações e trocas
    \item Testar com diferentes tipos de dados (strings, objetos complexos)
    \item Comparar com implementações nativas (\texttt{Arrays.sort()})
    \item Estudar o impacto de dados com muitos valores duplicados
    \item Medir consumo de memória e comportamento de cache
\end{itemize}

\newpage

\section{Referências}

\begin{itemize}
    \item GeeksforGeeks. \textit{Bubble Sort Algorithm}. Disponível em: \\ \texttt{https://www.geeksforgeeks.org/dsa/bubble-sort-algorithm/}. Acesso em: novembro de 2025.
    
    \item GeeksforGeeks. \textit{Insertion Sort Algorithm}. Disponível em: \\ \texttt{https://www.geeksforgeeks.org/dsa/insertion-sort-algorithm/}. Acesso em: novembro de 2025.
    
    \item GeeksforGeeks. \textit{Quick Sort Algorithm}. Disponível em: \\ \texttt{https://www.geeksforgeeks.org/dsa/quick-sort-algorithm/}. Acesso em: novembro de 2025.
    
\end{itemize}

\end{document}